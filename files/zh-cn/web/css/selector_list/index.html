---
title: 选择器列表
slug: Web/CSS/Selector_list
tags:
  - CSS
  - 层叠样式表
  - 选择器
translation_of: Web/CSS/Selector_list
---
<div>{{CSSRef}}</div>

<p>CSS <strong>选择器列表</strong>（<code>,</code>），常被称为并集选择器或并集组合器，选择所有能被列表中的任意一个选择器选中的节点。</p>

<pre class="brush: css no-line-numbers">/* 选择所有 &lt;span&gt; 和 &lt;div&gt; 元素 */
span, div {
  border: red 2px solid;
}</pre>

<p>为了使样式表更简洁，可以使用逗号分隔的列表来对选择器进行分组。</p>

<h2 id="语法">语法</h2>

<pre class="syntaxbox">element, element, element { <em>style properties</em> }</pre>

<h2 id="例子">例子</h2>

<h3 id="单行分组">单行分组</h3>

<p>在一行之中使用逗号为选择器分组。</p>

<pre class="brush: css">h1, h2, h3, h4, h5, h6 { font-family: helvetica; }
</pre>

<h3 id="多行分组">多行分组</h3>

<p>使用逗号对多行选择器进行分组。</p>

<pre class="brush: css">#main,
.content,
article {
  font-size: 1.1em;
}
</pre>

<h3 id="选择器列表无效化">选择器列表无效化</h3>

<p>使用选择器列表的一个缺点是，以下两段 CSS 代码并不不等价：</p>

<pre class="brush: css">h1 { font-family: sans-serif }
h2:maybe-unsupported { font-family: sans-serif }
h3 { font-family: sans-serif }</pre>

<pre class="brush: css">h1, h2:maybe-unsupported, h3 { font-family: sans-serif }</pre>

<p>这是因为，在选择器列表中如果有一个选择器不被支持，那么整条规则都会失效。</p>

<p>解决这个问题的一个方法是使用 {{CSSxRef(":is", ":is()")}} 选择器，它会忽视它的参数列表中失效的选择器，但是由于 {{CSSxRef(":is", ":is()")}}  会影响优先级的计算方式，这么做的代价是，其中的所有选择器都会拥有相同的优先级。</p>

<pre class="brush: css">h1 { font-family: sans-serif }
h2:maybe-unsupported { font-family: sans-serif }
h3 { font-family: sans-serif }</pre>

<pre class="brush: css">:is(h1, h2:maybe-unsupported, h3) { font-family: sans-serif }</pre>

<h2 id="规范">规范</h2>

{{Specifications}}

<h2 id="浏览器兼容性">浏览器兼容性</h2>



<p>{{Compat("css.selectors.list")}}</p>

<h2 id="参见">参见</h2>

<ul>
 <li>{{CSSxRef(":is", ":is()")}} {{Experimental_Inline}} 和 {{CSSxRef(":where", ":where()")}} {{Experimental_Inline}} 伪类，它们能避免选择器列表无效化的遗留设计错误。</li>
</ul>
